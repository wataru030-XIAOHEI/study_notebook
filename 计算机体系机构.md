# MIPS

## 静态流水线

### 数据相关

#### RAW 

##### 比较源寄存器：

比较源操作数寄存器，后续每个阶段的是否与目标寄存器的一致，控制前面的阶段继续（但会阻塞） 

##### 前递Forwarding技术 

* 在EX阶段的运算结果出来后直接送到后续指令的EX阶段 
* LW 要阻塞，可以通过调度减少阻塞 

 

#### WAW



#### WAR

---

### 控制相关

* 使用专门的地址运算部件把地址计算提前到译码阶段可以少等一拍
* 使用转移指令DELAY SLOT，可以不用等待

---

### 流水线和例外(Exception)

**有例外了才能跑OS**

**例外是每个模块都要加东西，不是一个专门的模块来处理例外。所以在编写流水线的时候就要考虑例外。**

**例外要考虑周全**

#### 例外原因

*  I/O请求：外部中断
* 指令例外：用户请求指令
  * 系统调用，断点，跟踪调试指令
* 运算部件
  * 整数运算溢出，*浮点异常*
* 存储管理部件
  * 访存地址不对齐，用户访存系统空间，TLB失效，缺页，存储保护错（写只读页）
* 保留指令错：未实现指令
* 硬件错
* etc.

 #### 例外发生的流水阶段

* 取指：访存例外（没找到指令）
* 译码：保留指令、中断指令如Trap，Syscall
* 执行：整数溢出，浮点异常（如除零），etc.
* 访存：访存意外
* 其他：外部中断，可能在任何时候发生

#### 例外特征

* 同步与异步（如敲键盘）
* 用户请求与系统强制
* 可屏蔽与不可屏蔽
* 指令内（除法溢出）与指令间（敲键盘）
* 可恢复与结束

#### 精确例外

发生例外的前面的指令要给他执行完，发生例外的后面指令不给他执行。

* store指令要保证前面没有发生例外，发生例外不能让store写
* 多条指令发生例外，要优先处理最前面的例外
* 延迟槽指令发生例外：
  * 处理完后要退回到跳转分支指令

#### 简单五级流水线例外处理

* 任何一级流水发生例外时，在流水线中记录下发生例外的事件，直到**WB阶段**再处理
* 如果再EX阶段要修改机器状态（如状态寄存器），保留下来直到**WB阶段**再修改，如果是MEM阶段，是STORE，要写值，要看WB的指令有没有发生例外，如果发生了，则STORE不能写。
* 指令的PC值随指令流水前进到**WB阶段**例外处理专用
* 外部中断作为IF的例外处理
* 指定一个通用寄存器中的某一个为例外处理时**保留PC值专用** （告诉OS哪条指令发生了例外，发生了什么例外）
* 发生例外的指令在WB阶段时：
  * 保留该指令的PC（也在WB阶段），有些机器还保留其状态
  * 设置PC值为例外处理程序入口地址（都是操作系统的地址）



### 多功能部件与多拍操作（动态流水线用）

#### 多功能部件

* 定点ALU
* 定点乘法
* 浮点ALU
* 浮点乘法
* 访存

##### 不同功能部件有不同延迟

* 定点ALU 1 拍， 
* 定点乘法2拍
* 浮点ALU 4 拍
* 浮点乘法7拍
* 访存部件延迟不确定（CACHE不命中、访存总线竞争、动态存储器刷新等原因），每次只能一个操作（内部不流水）

#### 引起的问题

##### 结构相关

* 访存部件不流水引起多个访存操作的等待
* 结果总线相关：不同功能部件的延迟不一致。定点ALU操作的MEM周期就是为了避免结果总线冲突的stall操作

##### WAW 相关

* 即使多端口写也会阻塞

##### 还是不会有WAR相关

* 读数总在较前的ID阶段

##### RAW相关更多

* 有些操作需要多拍产生结果
* FORWARDING的作用也很有限

##### 指令乱序结束

* 例外处理更加困难，例外发生难以意料



#### 通过流水线阻塞来保证避免数据冲突

* 比较目标寄存器号与源寄存器号

#### 结构相关解决：

* 通过请求与仲裁允许流水线前进

#### 例外处理

* 不管指令执行多少拍，都要***顺序***写回寄存器，而且所有例外在写回阶段进行统一处理

---

## 总结

静态流水线是基础。是动态流水线的基础。