# MIPS

关于MIPS-体系结构基础的简要介绍。学习记录随笔。以MIPS的视角来学习计算机体系结构。内容从静态流水线到动态流水线，会包括TLB,CACHE等内容。

## 静态流水线

### 数据相关

* <u>数据相关的指令不能并行执行</u>
* 寄存器的数据相关比较容易判断
* 存储器的数据相关不容易判断（转出虚拟地址之后通过TLB转成物理地址再判断）



#### RAW（真相关） 

##### 比较源寄存器：

比较源操作数寄存器，后续每个阶段的是否与目标寄存器的一致，控制前面的阶段继续（但会阻塞） 

##### 前递Forwarding技术 

* 在EX阶段的运算结果出来后直接送到后续指令的EX阶段 
* LW 要阻塞，可以通过调度减少阻塞  

#### WAW

reg名字相关会引起。

#### WAR

reg名字相关会引起。

---

### 控制相关（条件转移）

* 使用专门的地址运算部件把地址计算提前到译码阶段可以少等一拍
* 使用转移指令DELAY SLOT，可以不用等待

---

### 流水线和例外(Exception)

**有例外处理了才能跑OS**

**例外是每个模块都要加东西，不是一个专门的模块来处理例外。所以在编写流水线的时候就要考虑例外。**

**例外要考虑周全**

#### 例外原因

*  I/O请求：外部中断
* 指令例外：用户请求指令
  * 系统调用，断点，跟踪调试指令
* 运算部件
  * 整数运算溢出，*浮点异常*
* 存储管理部件
  * 访存地址不对齐，用户访存系统空间，TLB失效，缺页，存储保护错（写只读页）
* 保留指令错：未实现指令
* 硬件错
* etc.

 #### 例外发生的流水阶段

* 取指：访存例外（没找到指令）
* 译码：保留指令、中断指令如Trap，Syscall
* 执行：整数溢出，浮点异常（如除零），etc.
* 访存：访存意外
* 其他：外部中断，可能在任何时候发生

#### 例外特征

* 同步与异步（如敲键盘）
* 用户请求与系统强制
* 可屏蔽与不可屏蔽
* 指令内（除法溢出）与指令间（敲键盘）
* 可恢复与结束

#### 精确例外

发生例外的前面的指令要给他执行完，发生例外的后面指令不给他执行。

* store指令要保证前面没有发生例外，发生例外不能让store写
* 多条指令发生例外，要优先处理最前面的例外
* 延迟槽指令发生例外：
  * 处理完后要退回到跳转分支指令

#### 简单五级流水线例外处理

* 任何一级流水发生例外时，在流水线中记录下发生例外的事件，直到**WB阶段**再处理
* 如果再EX阶段要修改机器状态（如状态寄存器），保留下来直到**WB阶段**再修改，如果是MEM阶段，是STORE，要写值，要看WB的指令有没有发生例外，如果发生了，则STORE不能写。
* 指令的PC值随指令流水前进到**WB阶段**例外处理专用
* 外部中断作为IF的例外处理
* 指定一个通用寄存器中的某一个为例外处理时**保留PC值专用** （告诉OS哪条指令发生了例外，发生了什么例外）
* 发生例外的指令在WB阶段时：
  * 保留该指令的PC（也在WB阶段），有些机器还保留其状态
  * 设置PC值为例外处理程序入口地址（都是操作系统的地址）



### 多功能部件与多拍操作（动态流水线用）

#### 多功能部件

* 定点ALU
* 定点乘法
* 浮点ALU
* 浮点乘法
* 访存

##### 不同功能部件有不同延迟

* 定点ALU 1 拍， 
* 定点乘法2拍
* 浮点ALU 4 拍
* 浮点乘法7拍
* 访存部件延迟不确定（CACHE不命中、访存总线竞争、动态存储器刷新等原因），每次只能一个操作（内部不流水）

#### 引起的问题

##### 结构相关

* 访存部件不流水引起多个访存操作的等待
* 结果总线相关：不同功能部件的延迟不一致。定点ALU操作的MEM周期就是为了避免结果总线冲突的stall操作

##### WAW 相关

* 即使多端口写也会阻塞

##### 还是不会有WAR相关

* 读数总在较前的ID阶段

##### RAW相关更多

* 有些操作需要多拍产生结果
* FORWARDING的作用也很有限

##### 指令乱序结束

* 例外处理更加困难，例外发生难以意料



#### 通过流水线阻塞来保证避免数据冲突

* 比较目标寄存器号与源寄存器号

#### 结构相关解决：

* 通过请求与仲裁允许流水线前进

#### 例外处理

* 不管指令执行多少拍，都要***顺序***写回寄存器，而且所有例外在写回阶段进行统一处理







---



## 动态流水线

### CPI

每条指令时钟周期数，是目前最重要的指标。 = 理想CPI + 结构相关+ 3种数据相关 +控制相关 

### 循环展开技术

用在编译器。改变有相关性的指令的执行顺序。

过度展开Cache会放不下，所以要把控展开的幅度。

### 寄存器重命名（消除WAR,WAW）

是乱序执行处理器的关键特性。**把程序中的寄存器名映射到<u>大量</u>的内部物理寄存器。** 条件执行的问题是不管条件是否成立，都必须给这些指令中的寄存器分配相应的物理寄存器。<u>但内部物理寄存器的可用性是影响乱序处理器的关键性能资源。</u> 消除假相关之后可以进行编译调度（改变指令从次序）。

存储单元的重命名比较困难。

* <u> 只有访存指令与访存指令之间才有存储器相关性。</u>
* 执行之后也有可能导致速度没有之前的快（Cache放不下了）。

### 增加发射宽度

例如双发射结构。一次发射2条指令。



### 硬件调度

* 要有特定的机制来保证程序行为不被改变
* 关键是程序的数据与结构相关性得以保持
* 硬件调度一般只能在百条指令的范围内进行调度
* 可以掌控软件编译时还不明确的相关性信息。尤其<u>是对访存相关与控制相关。</u>
* <u>与软件调度是互补的。</u>

#### 动态调度技术

##### 静态流水线的问题

* 在译码阶段把指令“隔开”来解决相关
  * 只要有1条指令停止，后面指令就不能前进，像是一种译码部件的结构相关
* 对编译要求高，最好是编译把相关指令隔开
  * 有些信息在译码时难以确定，如：是否发生例外、访存操作需要多少周期等。

##### 动态调度思想

* 基本思想：<u>**有序进入，乱序执行，有序结束**</u>
  * 前面指令的等待不影响后面指令继续前进
  * 把相关的解决尽量往后拖延（***用的时候再判断相关***）
* **把译码阶段分为2个阶段**：**<u>发射和读操作数</u>**
  * <u>发射：**指令译码，检查结构相关**（*如2条除法指令接续过来，要等*）</u>
  * 读操作数：**如果操作数<u>准备好</u>就读数，否则等待（*<u>在哪等？</u>*）**-->(*<u>添加一个空间让他们等待，不要堵住后面的指令？</u>*)
  * 当一条指令在读操作数阶段等待时，*后面指令的发射可以继续进行*
* 乱序执行的**基本做法**：
  * 指令***进入是有序的***
  * 执行**可以乱序**，只要没有相关就可以执行，多条指令同时执行
  * *结束也是**有序的***（*精确例外*）（<u>如何把**乱序**变成**有序**？</u>） --->(<u>有个队列来给指令排好队，让他们有序结束</u>)
* 与*静态调度*相比
  * 有些相关编译无法检测，编译器更加简单、**程序性能对机器依赖少。**

##### 硬件寄存器重命名

有了这些，WAW 与WAR相关不用阻塞了。**可以彻底消除。**

* 每个[功能部件](#多功能部件)的<u>输入端</u>有一些**<u>寄存器</u>**。（微结构寄存器，软件读不了，硬件自用）
* 每个寄存器（包括功能部件输入端的寄存器以及通用寄存器）<u>**都记录一个功能部件号，指定它当前接收到哪个功能部件的值**</u>。
* 每个功能部件的**输出**接到每个功能部件的**输入**。
* 支持猜测性执行

###### Tomasulo算法

* **保留站/保留队列（微结构重命名寄存器）**内容：
  * Busy：忙位
  
  * Op：操作码
  
  * Vj，Vk：源操作数的值
  
  * Qj，Qk：**保存没有准备好的源操作数的保留站号**（0表示操作数已经准备好了。）
  * 作用：
    * <u>有序变乱序</u>，指令等待的地方
    * 重命名寄存器的作用，消除假相关。
* 结构寄存器增加1个域：

  * **结果状态域**：空表示寄存器值可用，否则保存产生寄存器结果的保留站号
* 结果总线：

  * 除了送回结果值以外，还要送回产生该结果的保留站号

<u>Tomasulo小结：</u>

* 通过动态调度缓解流水线阻塞
  * 例如减少cache失效对性能的影响
* 保留站：重命名寄存器+缓存源操作数
  * 避免寄存器成为瓶颈
  * 避免假相关阻塞
* 缺点：
  * 硬件复杂性
  * 结果总线成为瓶颈，多条结果总线增加硬件复杂度

#### 动态流水线的例外处理

回顾[例外（Exception）与流水线](#流水线和例外(Exception))

##### <u>动态流水线的精确例外处理</u>

* **精确例外的要求：**再处理例外时，发射例外指令前面的所有指令都哦执行完，例外发生之后的指令都未执行。
* 非精确例外的原因：再乱序执行时，前面的指令发生例外时，后面的指令已经执行完并修改了寄存器或存储单元
  * Tomasulo算法与计分板都是非精确例外
* <u>**只要保证后面的指令修改机器状态时，前面的指令都已不会发生例外即可。**</u>

##### 改造Tomasulo算法

执行的结果先不写回寄存器，确定前面不会发生例外，再写回结构寄存器里面去。

* **处理方法一**：把后面指令对机器状态的修改延迟到前面指令都已经执行完
  * 有些指令在EX阶段也修改机器状态，如运算指令修改结果状态。
  * 在i执行阶段停止流水线会影响后面的指令执行。
* **处理方法二**：可以用一些**微结构缓冲器**来**临时保存执行结果**，当前面的所有指令执行完之后，再把保存在缓冲器中的结果写回到寄存器或存储器。
  * 在流水线修改机器状态时（在执行或者写回阶段），写到缓冲器
  * 增加**提交（Commit）**阶段，把缓冲器中的内容写回到寄存器或者存储器。
  * 提交阶段只有前面指令都结束才能进行。
  * **<u>有序提交：乱序执行，有序结束。</u>**
  * 所用的缓冲器常被称为***<u>Record Buffer（ROB）</u>***
* 在**猜测执行（？）**中也用到上述机制
  * 都是在 某些情况不确定下先执行，但留有反悔的余地。

##### ROB指令重排序缓存

内容：目标地址（存数地址或寄存器号）、值、操作类型

写回时写回到ROB。因此，后面的指令有可能从ROB中读取操作数

使用ROB作为重命名号（原来使用保留站号），一条指令的结果寄存器被重命名为其结果ROB号

* 保留站重命名源寄存器号
* ROB重命名结果寄存器号

**提交时**把结果写回寄存器或存储器,如果其他寄存器要读新值，要去读ROB的值

只要一条指令没有提交，它就不会对寄存器或存储器的内容进行修改，在一条指令没有提交之前，很容易取消该指令（由于**前面指令发生了例外**或者由于**猜测执行不正确**）

**ROB**可以和**WriteBuffer**合并

##### 增加ROB流水线

* 发射：把操作队列的指令根据操作类型送到保留站（如果保留站**以及ROB有空**），**<u>并且在ROB中指定一项作为临时保存该指令结果之用</u>**；发射过程中读寄存器的值与结果状态域，<u>**如果结果状态域指出结果寄存器已被重命名到ROB，则读ROB**</u>。
* 执行：如果所需的操作数都准备好，则执行，否则根据结果ROB号侦听结果总线并且接受结果总线的值
* 写回：把结果送到结果总线，释放保留站；**ROB根据结果总线修改相应项**
* <u>**提交：如果队列中第一条指令的结果以及写回并且没发生例外，把该指令的结果从ROB协会到寄存器或者存储器，释放ROB的相应项。如果队列头的指令发生例外或是猜测错误的转移指令，清除操作队列以及ROB等。**</u>



---

## 多发射

### 多发射数据通路（本章内容列表）

* 乱序执行的关键技术
* 动态调度流水线数据通路
  * 保留站的组织
  * 寄存器与保留站的关系
  * 寄存器重命名方法
* 多发射结构数据通路

### 影响动态调度的主要因素

* 指令缓存结构：
  * 独立保留站：每个运算部件都有一个
  * 组保留站： 定点一个、浮点一个
  * 全局保留站：所有共用一个
* 读取寄存器内容时间
  * 保留站前读
  * 保留站后读
* 寄存器重命名的方法
  * 重命名寄存器和物理寄存器<u>分开</u>
  * 重命名寄存器与物理寄存器<u>合并</u>

#### 指令缓存结构

##### 保留站组织：

* 独立保留站：

​	每个保留站项数较少，只要一个写端口和一个读端口。输出选择比较简单。**但是利用率低，闲的闲死，忙的忙死甚至引起堵塞。**结果总线送到所有保留站，连线长，结果写回可能需要单独一拍，（**决定CPU主频目前是连线的长度。**）

* 组保留站：

​	每个保留站项数较多，**每个保留站需要多个写入端口，多个读端口，保留站读出可能需要单独一拍**。效率较高。**结果总线不用送到每个功能部件。**一般划分时考虑定点、浮点、访存。

* 全局保留站：

​	保留站项数很多。读出写入端口都很多。读出时间长，保留站控制很复杂。效率高。结果总线只送回到全局保留站。

##### 寄存器与保留站的关系：

* 保留站前读寄存器
  * 保留站中有值域，较复杂
  * 操作数没准备好就读寄存器，保留站侦听总线结果
  * 有序发射

寄存器的输出作为保留站的输入。

* 操作数没有准备好就读寄存器，保留站侦听结果总线获取没写回的值
* 有序读寄存器
* 保留站值的来源：寄存器、重命名寄存器、进入保留站时侦听、进入保留站后侦听
* 保留站中有值域，因此比较复杂
* **寄存器读端口数为发射宽度**

---

* 保留站后读寄存器
  * 保留站中无值域
  * 操作数全部准备好之后才能读寄存器
  * 乱序发射

保留站的输出作为寄存器的输入

* 保留站确信所有值都已经准备好后再写回寄存器，***有可能有前递的情况***。
* 乱序读寄存器
* 保留站中**没有值域**，**只存寄存器号**，**寄存器只要读一遍，写一遍**
* 寄存器读端口数为相应功能部件



### ==寄存器重命名方法==

#### 重命名技术

* 双重作用：
  * 例外或转移猜测错误时**取消后面的操作**
  * 解决假相关
* ***核心思想***
  * **一个操作写寄存器时重命名到其他寄存器**
  * **一个操作结束时再写到结构寄存器**

#### 方法

多种多样

* 软件重命名
* 重命名到保留站
* 重命名到ROB
* 重命名到发射队列
* ==重命名寄存器与结构寄存器不分开:==建立**物理寄存器**到**逻辑寄存器**的映射（主流）（老的，即为使用过的逻辑寄存器在提交之后就可以释放给别的指令使用）
  * 这种重命名的好处（比起重命名到ROB）：省功耗。【每次只要写到一个地方】
  * 刚分配的时候只有一个最新的
  * ==为每个逻辑寄存器**动态**分配物理寄存器，需要**建立**逻辑寄存器和物理寄存器的**映射表。（哪些有空，哪些是最新的）。**==
  * ==映射表可以是**RAM**的方式，即：逻辑寄存器有那么多项，也可以是CAM的方式，即物理寄存器有那么多项。==


==就是只要找到一个方法临时存数据==

---

#### 独立重命名寄存器的重命名算法

##### 译码阶段

* 为目标寄存器分配一个空闲的重命名寄存器
* 为源寄存器找到相应的重命名或结构寄存器号
* 读操作数（注意三种操作数来源）并送入保留站

##### 发射阶段

* 在保留站中找操作数准备好的操作进行运算，不涉及重命名

##### 执行阶段

* 执行结果协会到重命名寄存器
* 写回到侦听该重命名寄存器值的保留站
* 不写回结构寄存器

##### 提交阶段

* 把重命名寄存器的值写回到相对应得结构寄存器
* 释放相应的重命名寄存器

##### 转移猜错或例外

* 取消后面的已经建立的重命名关系
* 把结构寄存器的状态都置为有效
* 把重命名寄存器的状态都置为空

##### ==重命名寄存器的状态==

* **EMPTY:**表示该寄存器没被重命名（重命名后又已经释放）
* **MAPPED**:表示已经被重命名但结果还没写回
* **WRIYEBACK**:表示结果已经写回重命名寄存器**但没有Commit**到结构寄存器

##### ==结构寄存器的状态==

* **VALID**：表示相应寄存器的值可用
* **INVALID**：表示相应寄存器的值不可用

##### ==映射关系==

* 可在结构寄存器中增加一个指向重命名寄存器的**重命名寄存器号域**

---

#### **==使用物理寄存器堆的重命名算法==**

假设保留站后读寄存器

##### 译码阶段

* 把目标寄存器映射到一个空闲的物理寄存器
* 为源寄存器根据依赖关系找到相应的物理寄存器号
* 把重命名后的寄存器号写入保留站

##### 发射阶段

* 判断所需的操作数是否已经准备好，或（forwarding情况下）正在写回
* 从物理寄存器或结果总线中读寄存器的值

##### 执行阶段

* 执行结果根据目标物理寄存器号写回到物理寄存器
* 不用写回到保留站

##### 提交阶段

* 修改重命名表，确认目标寄存器的重命名关系
* 释放老的目标寄存器重命名关系

##### 转移猜错或例外

* 修改重命名表取消后面的已经建立的重命名关系
* 把状态为MAPPED或WRITEBACK的都置为EMPTY
* 确认状态为COMIIT的映射为相应的逻辑寄存器的最新映射

##### ==核心是重命名表==

* 可以用CAM或者RAM的方法
* 项数与物理寄存器一样

###### 主要包括三个域

* name：相对应的逻辑寄存器号
* state ：状态：**EMPTY**：表示该寄存器没有被重命名（重命名后又已经被释放）；**MAPPED**：表示已经被重命名但结果还没被写回；**WRITEBACK**：表示结果已经写回重命名寄存器但没有Commit到结构寄存器，**Commit**：表示结果已经被确认
* vaild：在一个逻辑寄存器对应多个物理寄存器的情况下表示最新映射。

#### ==乱序执行的数据通路==

**三方面考虑。**

* 保留站结构（独立，分组，全局）
* 读操作数时机（译码（战前），发射（战后））
* 重命名方式（重命名寄存器与结构寄存器分开/不分开）

所以有3\*2\*2=12种组合方式。

* **保留站后读操作数可以减少一次源操作数拷贝（从寄存器到保留站）**
* **物理寄存器堆可以减少一次结果操作数拷贝（从物理寄存器到结构寄存器）**



### 多发射结构数据通路

#### 多发射的情况

* 数据通路变宽
  * Alpha21264：取值4条，发射6条，写回6条，commite11条
  * 寄存器读端口变多
  * 访存端口要求也增加
* 同一排发射的指令之间的相关
  * 入在重命名阶段发射同一拍之间的关系
* 流水线复杂度与发射宽度成平方关系
  * 如发射队列（保留站）变大 *（读端口变多+侦听端口变多）**发射宽度变宽，发射队列要变长**
  * 如寄存器重命名端口变多*同一拍重命名指令相关 **相关判断**

#### 多发射的其他设计问题

* 同时提交多条指令
  * 重命名把有序变乱序，要除了**“前后看”**还要**“左右看”**
  * 提交把无序变成有序，也要左右看：同一排可以提交多条，**第二条是否提交要看第一条是否提交**，等等。
* 指令发射与**读寄存器**
  * **多端口寄存器**是物理设计的<u>难点</u>：会增加延迟、面积、功耗、***四发射结构一般需要4写8读的寄存器***
  * 指令发射逻辑：从保留站中同时找出多条数据准备好了的指令，为了性能要适当考虑在数据准备好了的情况下前面的指令先发射
* 多功能部件
  * 增加回端口：寄存器堆、重命名寄存器、重命名寄存器表、ROB、发射队列
  * 尤其是多访存部件会大大增加设计复杂度

![image-20220317203632498](C:/Users/wataru/Desktop/ysyx%E8%AE%B0%E5%BD%95/image-20220317203632498.png)

### 寄存器重命名

#### 功能

* 把逻辑寄存器号转化为物理寄存器号
* 消除WAR与WAW相关，奖励RAW相关关系

#### 使用CAM寄存器重命名表，每一项包括如下内容（每一项3个域）

* State ：四个状态：EMPTY,MAPPEAD,WRITEBACK,COMMIT<u>（任何逻辑寄存器处于提交状态的物理寄存器只有一个）</u>
* Name： 该物理寄存器对应的逻辑寄存器号
* valid：在多个物理寄存器对于一个逻辑寄存器时表示哪个是最近是被映射的
* 其他

#### 操作

* 重命名：为目标寄存器分配一个空闲的物理寄存器（状态置为MAPPED），为源寄存器根据依赖关系找到相应的物理寄存器号
* 执行：把重命名寄存器的状态置为**WRITEBACK**
* 提交：**<u>*把目标寄存器的值变为软件可见。*</u>**（把重命名寄存器的状态置为COMMIT），释放原来的重命名寄存器（状态置为EMPTY）
* 转移猜错或例外：取消后面的已经建立的重命名关系。

![image-20220317204731980](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220317204731980.png)



---

## 总结

静态流水线是基础。是动态流水线的基础。

RISC<u>技术极大地简化了指令之间的相关性。</u>

#### 动态流水线小结

* 有序进入，乱序执行，有序结束
* 主要数据结构
  * ***保留站***（发射队列）把有序变成乱序，<u>临时存指令</u>
  * ***重命名寄存器***用于<u>保存未提交的临时结果，临时存数据</u>
  * ROB把乱序重新变成有序
* 乱序的能力和有关队列大小紧密相关
  * 现代高性能CPU一般都有100条指令在流水线中乱序执行。







---



































# RISC-V --ISA

*PIC:位置无关代码*

* **RV32I：固定不变的基础整数指令集，RV核心内容。**
* RV32M：乘法与除法
* RV32F,RV32D：浮点操作
* RV32A ：原子操作
* RV32C：可选的压缩拓展
* RV32V：向量拓展。它通过向量寄存器指定数据类型与长度
* **RV64G：64位地址版本。**

## 指令格式

所有指令都是32位长度。

RV指令提供**3个寄存器操作数**

### R类型指令

寄存器-寄存器操作

### I类型指令

用于**短**立即数与访存load操作

### S类型指令

用于访存store操作

### B类型指令

用于条件跳转操作。B类型的立即数字段在S类型的基础上旋转了1位。

### U类型指令

用于长立即数

### J类型指令

用于无条件跳转。J类型的直接字段在U类型的基础上旋转了12位。

---

![image-20220305162831337](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220305162831337.png)

RV32I指令集的各种指令

### RV指令格式

![image-20220305163005113](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220305163005113.png)

#### RV32I指令操作码映射表

![image-20220305163254027](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220305163254027.png)

![image-20220305163318861](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220305163318861.png)

![image-20220305163339849](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220305163339849.png)

* TODO: *所有位为0是非法的RV32I指令。*因此，试图跳转到被清零的内存区域的错误跳转会触发异常。
* TODO:*所有位都是1的指令也是非法指令，**它将捕获其他常见的错误，诸如未变成的EEPROM设备、断开链接的内存BUS或者坏掉的内存芯片。***

* **B 和 J 格式的分支和跳转地址必须向左移动 1 位以将地址乘以 2**

## RV32I 寄存器

其中，x0号寄存器恒为0，还包括其他各种指针(sp,gp,tp,fp)寄存器。保存寄存器(s0-s11)，临时寄存器(t0-t6)，PC指针寄存器。

![](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220305164619434.png)

## RV32I的load和store

* 有符号字节和半字，符号拓展为32位之后再写入目的寄存器，无符号字节都被无符号拓展至32位。
* **加载和存储的支持的位移寻址模式是符号拓展12位立即数到基地址寄存器。**
* 不支持延迟加载。
* 普通的加载和存储指令支持不对齐访问。

## RV32I条件分支

假如计算64bits数据的加法：
![image-20220314154836710](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220314154836710.png)

其中。sltu判断充当低位到高位的加法的进位。

*获得PC值可以用auipc zero来获取*

## RV32I无条件跳转

jal作用：

* 返回地址寄存器ra，实现过程调用
* 使用 0号寄存器替代ra做模板寄存器，实现无条件跳转。

## RV32I杂项

控制状态寄存器指令（csrrc,csrrs,csrrw,csrrci,csrrsi,csrrwi），可以轻松范围一些程序性能计数器，对于这些64位的计数器，我们一次可以读取32位。这些计数器包括了系统时间，时钟周期，以及执行的指令数目。

![image-20220314160003675](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220314160003675.png)

## RV32I特点

![image-20220314160659568](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220314160659568.png)

## RVI32汇编

变量应该尽量存放在寄存器而不是内存中，调试也要注意避免频繁地保存和恢复寄存器。移位它们同样会访问内存。

![image-20220314165254661](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220314165254661.png)

![image-20220314165350248](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220314165350248.png)

### 函数调用中，各寄存器二进制接口ABI与规定表

![image-20220314165358697](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220314165358697.png)

![image-20220314165749217](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220314165749217.png)

如果参数与局部变量太多：

![image-20220314165939466](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220314165939466.png)

### RV32I伪指令

![image-20220314170626316](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220314170626316.png)

![image-20220314170658359](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220314170658359.png)

### 链接器

允许各个文件独立的进行编译与汇编，在改动部分文件时，不需要重新编译全部源代码。



### RV32I函数分配内存方式

![image-20220314171531675](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220314171531675.png)

## RV32M（乘除法）

![image-20220314172318998](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220314172318998.png)

其中`rem`是向目的寄存器写回**余数**

![image-20220314172623305](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220314172623305.png)

![image-20220314172816787](https://raw.githubusercontent.com/wataru030-XIAOHEI/picgo/main/image-20220314172816787.png)







